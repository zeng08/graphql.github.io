<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>授权 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta property="og:description" content="GraphQL 提供了 API 中数据的完整描述，提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，让 API 更加容易随着时间推移而演进，并提供强大的开发者工具。"/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.cn/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta name="twitter:description" content="GraphQL 提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，并让 API 更加容易随着时间推移而演进。"/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL 团队博客"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">学习</a><a href="/code/">代码</a><a href="/community/">社区</a><a href="/blog/">博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">规范</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="搜索文档..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>授权</h1><div><blockquote><p>将授权逻辑委托给业务逻辑层</p></blockquote><p>授权是一种业务逻辑，描述给定的用户、会话、上下文是否具有执行操作的权限或查看一条数据的权限。例如：</p><p><strong>“只有作者才能看到他们自己的草稿”</strong></p><p>应当在 <a href="/learn/thinking-in-graphs/#业务逻辑层">业务逻辑层</a> 实施这种行为。在 GraphQL 层中放置授权逻辑是很吸引人的，如下所示：</p><pre class="prism language-javascript"><span class="keyword">var</span> postType <span class="operator">=</span> <span class="keyword">new</span> <span class="class-name">GraphQLObjectType</span><span class="punctuation">(</span><span class="punctuation">{</span>
  name<span class="punctuation">:</span> <span class="string">&#x27;Post&#x27;</span><span class="punctuation">,</span>
  fields<span class="punctuation">:</span> <span class="punctuation">{</span>
    body<span class="punctuation">:</span> <span class="punctuation">{</span>
      type<span class="punctuation">:</span> GraphQLString<span class="punctuation">,</span>
      resolve<span class="punctuation">:</span> <span class="punctuation">(</span>post<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">,</span> <span class="punctuation">{</span> rootValue <span class="punctuation">}</span><span class="punctuation">)</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="punctuation">{</span>
        <span spellcheck="true" class="comment">// 只有当用户是帖子的作者时才返回帖子正文</span>
        <span class="keyword">if</span> <span class="punctuation">(</span>context<span class="punctuation">.</span>user <span class="operator">&amp;&amp;</span> <span class="punctuation">(</span>context<span class="punctuation">.</span>user<span class="punctuation">.</span>id <span class="operator">===</span> post<span class="punctuation">.</span>authorId<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">{</span>
          <span class="keyword">return</span> post<span class="punctuation">.</span>body<span class="punctuation">;</span>
        <span class="punctuation">}</span>
        <span class="keyword">return</span> <span class="keyword">null</span><span class="punctuation">;</span>
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span></pre><p>可以看到我们通过检查帖子的 <code>authorId</code> 字段是否等于当前用户的 <code>id</code> 来定义“作者拥有一个帖子”。你能发现其中的问题吗？我们需要复制这段代码到服务中的每一个入口端点。一旦我们无法保证授权逻辑的完全同步，用户可能在使用不同的 API 时看到不同的数据。我们可以通过确定授权的 <a href="/learn/thinking-in-graphs/#业务逻辑层">唯一真实来源</a> 来避免这种情况。</p><p>在学习 GraphQL 或原型设计时，在解析器内定义授权逻辑是可以接受的。然而，对于生产代码库来说，还是将授权逻辑委托给业务逻辑层。这里有一个例子：</p><pre class="prism language-javascript"><span spellcheck="true" class="comment">// 授权逻辑在 postRepository 中</span>
<span class="keyword">var</span> postRepository <span class="operator">=</span> <span class="function">require</span><span class="punctuation">(</span><span class="string">&#x27;postRepository&#x27;</span><span class="punctuation">)</span><span class="punctuation">;</span>

<span class="keyword">var</span> postType <span class="operator">=</span> <span class="keyword">new</span> <span class="class-name">GraphQLObjectType</span><span class="punctuation">(</span><span class="punctuation">{</span>
  name<span class="punctuation">:</span> <span class="string">&#x27;Post&#x27;</span><span class="punctuation">,</span>
  fields<span class="punctuation">:</span> <span class="punctuation">{</span>
    body<span class="punctuation">:</span> <span class="punctuation">{</span>
      type<span class="punctuation">:</span> GraphQLString<span class="punctuation">,</span>
      resolve<span class="punctuation">:</span> <span class="punctuation">(</span>post<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">,</span> <span class="punctuation">{</span> rootValue <span class="punctuation">}</span><span class="punctuation">)</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="punctuation">{</span>
        <span class="keyword">return</span> postRepository<span class="punctuation">.</span><span class="function">getBody</span><span class="punctuation">(</span>context<span class="punctuation">.</span>user<span class="punctuation">,</span> post<span class="punctuation">)</span><span class="punctuation">;</span>
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">;</span></pre><p>在上面的例子中，我们看到业务逻辑层要求调用者提供一个用户对象。如果您使用 GraphQL.js，您应当在解析器的 <code>context</code> 参数或是第四个参数中的 <code>rootValue</code> 上填充 User 对象。</p><p>我们建议将完全混合 <sup><a href="#note1">[1]</a></sup> 的 User 对象传递给业务逻辑层，而非传递不透明的 token 或 API 密钥。这样，我们可以在请求处理管道的不同阶段处理 <a href="/graphql-js/authentication-and-express-middleware/">身份验证</a> 和授权的不同问题。</p><div><ol>
<li><a name="note1"></a> “混合（hydrated）”一个对象是指：对一个存储在内存中且尚未包含任何域数据（“真实”数据）的对象，使用域数据（例如来自数据库、网络或文件系统的数据）进行填充。 <a href="https://stackoverflow.com/questions/6991135/what-does-it-mean-to-hydrate-an-object">*</a></li>
</ol>
</div></div><a class="read-next" href="/learn/pagination"><span class="read-next-continue">继续阅读 →</span><span class="read-next-title">分页</span></a></div><div class="nav-docs"><div><h3>学习</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">入门</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">查询和变更</a><ul><li><a href="/learn/queries/#fields">字段（Fields）</a></li><li><a href="/learn/queries/#arguments">参数（Arguments）</a></li><li><a href="/learn/queries/#aliases">别名（Aliases）</a></li><li><a href="/learn/queries/#fragments">片段（Fragments）</a></li><li><a href="/learn/queries/#operation-name">操作名称（Operation Name）</a></li><li><a href="/learn/queries/#variables">变量（Variables）</a></li><li><a href="/learn/queries/#directives">指令（Directives）</a></li><li><a href="/learn/queries/#mutations">变更（Mutations）</a></li><li><a href="/learn/queries/#inline-fragments">内联片段（Inline Fragments）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schema 和类型</a><ul><li><a href="/learn/schema/#type-system">类型系统（Type System）</a></li><li><a href="/learn/schema/#type-language">类型语言（Type Language）</a></li><li><a href="/learn/schema/#object-types-and-fields">对象类型和字段（Object Types and Fields）</a></li><li><a href="/learn/schema/#arguments">参数（Arguments）</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">查询和变更类型（The Query and Mutation Types）</a></li><li><a href="/learn/schema/#scalar-types">标量类型（Scalar Types）</a></li><li><a href="/learn/schema/#enumeration-types">枚举类型（Enumeration Types）</a></li><li><a href="/learn/schema/#lists-and-non-null">列表和非空（Lists and Non-Null）</a></li><li><a href="/learn/schema/#interfaces">接口（Interfaces）</a></li><li><a href="/learn/schema/#union-types">联合类型（Union Types）</a></li><li><a href="/learn/schema/#input-types">输入类型（Input Types）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">验证</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">执行</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">内省</a></li></ul></div><div><h3>最佳实践</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">介绍</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">关于 Graphs 的思考</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">通过 HTTP 提供服务</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">授权</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">分页</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">缓存</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">学习</a></h5><a href="/learn/">入门</a><a href="/learn/queries/">查询语言</a><a href="/learn/schema/">类型系统</a><a href="/learn/execution/">执行</a><a href="/learn/best-practices/">最佳实践</a></div><div><h5><a href="/code">代码</a></h5><a href="/code/#server-libraries">服务端</a><a href="/code/#graphql-clients">客户端</a><a href="/code/#tools">工具</a></div><div><h5><a href="/community">社区</a></h5><a href="/community/upcoming-events/">即将到来的活动</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>更多</h5><a href="/blog">GraphQL 团队博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">阅读规范</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GitHub</a><a href="https://github.com/xitu/graphql.github.io/edit/zh-Hans/site/learn/BestPractice-Authorization.md" target="_blank" rel="noopener noreferrer">编辑本页 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script></body></html>