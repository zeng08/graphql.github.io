<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>缓存 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta property="og:description" content="GraphQL 提供了 API 中数据的完整描述，提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，让 API 更加容易随着时间推移而演进，并提供强大的开发者工具。"/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.cn/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta name="twitter:description" content="GraphQL 提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，并让 API 更加容易随着时间推移而演进。"/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL 团队博客"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">学习</a><a href="/code/">代码</a><a href="/community/">社区</a><a href="/blog/">博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">规范</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="搜索文档..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>缓存</h1><div><blockquote><p>提供对象的标识符以便客户端构建丰富的缓存</p></blockquote><p>在基于入口端点的 API 中，客户端可以使用 HTTP 缓存来确定两个资源是否相同，从而轻松避免重新获取资源。这些 API 中的 URL 是<strong>全局唯一标识符</strong>，客户端可以利用它来构建缓存。然而，在 GraphQL 中，没有类似 URL 的基元能够为给定对象提供全局唯一标识符。这里提供为 API 暴露这种标识符以供客户端使用的最佳实践。</p><h2><a class="anchor" name="全局唯一-id"></a>全局唯一 ID <a class="hash-link" href="#全局唯一-id">#</a></h2><p>一个可行的模式是将一个字段（如 <code>id</code>）保留为全局唯一标识符。这些文档中使用的示例模式使用此方法：</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>这是向客户端开发人员提供的强大工具。与基于资源的 API 使用 URL 作为全局唯一主键的方式相同，该系统中提供 <code>id</code> 字段作为全局唯一主键。</p><p>如果后端使用类似 UUID 的标识符，那么暴露这个全局唯一 ID 可能非常简单！如果后端对于每个对象并未分配全局唯一 ID，则 GraphQL 层可能需要构造此 ID。通常来说，将类型的名称附加到 ID 并将其用作标识符都很简单；服务器可能会通过 base64 编码使该 ID 不透明。</p><h2><a class="anchor" name="与现有-api-的兼容"></a>与现有 API 的兼容 <a class="hash-link" href="#与现有-api-的兼容">#</a></h2><p>为了这一目的而使用 <code>id</code> 字段的一个问题是如何让使用 GraphQL API 的客户端能够与现有的 API 并存。例如，如果我们现有的 API 接受了特定类型的 ID，但是我们的 GraphQL API 使用了全局唯一 ID，那么同时使用两者可能比较棘手。</p><p>在这些情况下，GraphQL API 可以在单独的字段中暴露以前的 API 的 ID。这同时带给我们两方面的好处：</p><ul><li>GraphQL 客户端可以继续依靠一致的机制来获取全局唯一 ID。</li><li>当客户端需要使用我们以前的 API 时也可以从对象中获取 <code>previousApiId</code> 并使用它。</li></ul><h2><a class="anchor" name="备选方案"></a>备选方案 <a class="hash-link" href="#备选方案">#</a></h2><p>虽然全局唯一 ID 在过去已经被证明是一种强大的模式，但它们并不是唯一可以使用的模式，也不适用于每种情况。客户端需要的真正关键功能是为其缓存导出全局唯一标识符的能力。服务器可以导出此 ID 以简化客户端，而客户端同样也可以导出标识符。通常，将对象的类型（通过 <code>__typename</code> 查询）与某些类型唯一标识符相结合就很简单。</p><p>另外，如果使用 GraphQL API 替换现有的 API，那么如果 GraphQL 中的其他所有字段都相同，<strong>只</strong>更换了全局唯一的 <code>id</code>，这可能会令人困惑。这可能是为什么不选用 <code>id</code> 作为全局唯一字段的另一个原因。</p></div></div><div class="nav-docs"><div><h3>学习</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">入门</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">查询和变更</a><ul><li><a href="/learn/queries/#fields">字段（Fields）</a></li><li><a href="/learn/queries/#arguments">参数（Arguments）</a></li><li><a href="/learn/queries/#aliases">别名（Aliases）</a></li><li><a href="/learn/queries/#fragments">片段（Fragments）</a></li><li><a href="/learn/queries/#operation-name">操作名称（Operation Name）</a></li><li><a href="/learn/queries/#variables">变量（Variables）</a></li><li><a href="/learn/queries/#directives">指令（Directives）</a></li><li><a href="/learn/queries/#mutations">变更（Mutations）</a></li><li><a href="/learn/queries/#inline-fragments">内联片段（Inline Fragments）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schema 和类型</a><ul><li><a href="/learn/schema/#type-system">类型系统（Type System）</a></li><li><a href="/learn/schema/#type-language">类型语言（Type Language）</a></li><li><a href="/learn/schema/#object-types-and-fields">对象类型和字段（Object Types and Fields）</a></li><li><a href="/learn/schema/#arguments">参数（Arguments）</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">查询和变更类型（The Query and Mutation Types）</a></li><li><a href="/learn/schema/#scalar-types">标量类型（Scalar Types）</a></li><li><a href="/learn/schema/#enumeration-types">枚举类型（Enumeration Types）</a></li><li><a href="/learn/schema/#lists-and-non-null">列表和非空（Lists and Non-Null）</a></li><li><a href="/learn/schema/#interfaces">接口（Interfaces）</a></li><li><a href="/learn/schema/#union-types">联合类型（Union Types）</a></li><li><a href="/learn/schema/#input-types">输入类型（Input Types）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">验证</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">执行</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">内省</a></li></ul></div><div><h3>最佳实践</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">介绍</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">关于 Graphs 的思考</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">通过 HTTP 提供服务</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">授权</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">分页</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">缓存</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">学习</a></h5><a href="/learn/">入门</a><a href="/learn/queries/">查询语言</a><a href="/learn/schema/">类型系统</a><a href="/learn/execution/">执行</a><a href="/learn/best-practices/">最佳实践</a></div><div><h5><a href="/code">代码</a></h5><a href="/code/#server-libraries">服务端</a><a href="/code/#graphql-clients">客户端</a><a href="/code/#tools">工具</a></div><div><h5><a href="/community">社区</a></h5><a href="/community/upcoming-events/">即将到来的活动</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>更多</h5><a href="/blog">GraphQL 团队博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">阅读规范</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GitHub</a><a href="https://github.com/xitu/graphql.github.io/edit/zh-Hans/site/learn/BestPractice-Caching.md" target="_blank" rel="noopener noreferrer">编辑本页 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.45dd9fe78ffc34bc0d9b.js"></script></body></html>