<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>通过 HTTP 提供服务 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta property="og:description" content="GraphQL 提供了 API 中数据的完整描述，提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，让 API 更加容易随着时间推移而演进，并提供强大的开发者工具。"/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.cn/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta name="twitter:description" content="GraphQL 提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，并让 API 更加容易随着时间推移而演进。"/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL 团队博客"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">学习</a><a href="/code/">代码</a><a href="/community/">社区</a><a href="/blog/">博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">规范</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="搜索文档..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>通过 HTTP 提供服务</h1><div><p>使用 GraphQL 时，最常见被选用的客户端到服务器协议是无处不在的 HTTP。以下是设置 GraphQL 服务器以通过 HTTP 进行操作的一些准则。</p><h2><a class="anchor" name="网络请求管道"></a>网络请求管道 <a class="hash-link" href="#网络请求管道">#</a></h2><p>大多数现代 Web 框架使用一个管道模型，通过一组中间件（也称为过滤器/插件）堆栈传递请求。当请求流经管道时，它可以被检查、转换、修改、或是返回响应并终止。GraphQL 应当被放置在所有身份验证中间件之后，以便你在 HTTP 入口端点处理器中能够访问到相同的会话和用户信息。</p><h2><a class="anchor" name="uri-和路由"></a>URI 和路由 <a class="hash-link" href="#uri-和路由">#</a></h2><p>HTTP 通常与 REST 相关联，REST 使用“资源”作为其核心概念。相比之下，GraphQL 的概念模型是一个实体图。因此，GraphQL 中的实体无法通过 URL 识别。相反，GraphQL 服务器在单个 URL /入口端点（通常是 <code>/graphql</code>）上运行，并且所有提供服务的 GraphQL 请求都应被导向此入口端点。</p><h2><a class="anchor" name="http-方法、标题和正文"></a>HTTP 方法、标题和正文 <a class="hash-link" href="#http-方法、标题和正文">#</a></h2><p>你的 GraphQL HTTP 服务器应当能够处理 HTTP GET 和 POST 方法。</p><h3><a class="anchor" name="get-请求"></a>GET 请求 <a class="hash-link" href="#get-请求">#</a></h3><p>在收到一个 HTTP GET 请求时，应当在 “query” 查询字符串（query string）中指定 GraphQL 查询。例如，如果我们要执行以下 GraphQL 查询：</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  me <span class="punctuation">{</span>
    name
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>此请求可以通过 HTTP GET 发送，如下所示：</p><pre class="prism language-undefined">http<span class="punctuation">:</span><span class="operator">/</span><span class="operator">/</span>myapi<span class="operator">/</span>graphql<span class="operator">?</span>query<span class="operator">=</span><span class="punctuation">{</span>me<span class="punctuation">{</span>name<span class="punctuation">}</span><span class="punctuation">}</span></pre><p>查询变量可以作为 JSON 编码的字符串发送到名为 <code>variables</code> 的附加查询参数中。如果查询包含多个具名操作，则可以使用一个 <code>operationName</code> 查询参数来控制哪一个应当执行。</p><h3><a class="anchor" name="post-请求"></a>POST 请求 <a class="hash-link" href="#post-请求">#</a></h3><p>标准的 GraphQL POST 请求应当使用 <code>application/json</code> 内容类型（content type），并包含以下形式 JSON 编码的请求体：</p><pre class="prism language-js"><span class="punctuation">{</span>
  <span class="string">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span>
  <span class="string">&quot;operationName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span>
  <span class="string">&quot;variables&quot;</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="string">&quot;myVariable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;someValue&quot;</span><span class="punctuation">,</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span> <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p><code>operationName</code> 和 <code>variables</code> 是可选字段。仅当查询中存在多个操作时才需要 <code>operationName</code>。</p><p>除了上边这种请求之外，我们还建议支持另外两种情况：</p><ul><li>如果存在 “query” 这一查询字符串参数（如上面的 GET 示例中），则应当以与 HTTP GET 相同的方式进行解析和处理。</li><li>如果存在 “application/graphql” Content-Type 头，则将 HTTP POST 请求体内容视为 GraphQL 查询字符串。</li></ul><p>如果你使用的是 express-graphql，那么你已经直接获得了这些支持。</p><h2><a class="anchor" name="响应"></a>响应 <a class="hash-link" href="#响应">#</a></h2><p>无论使用任何方法发送查询和变量，响应都应当以 JSON 格式在请求正文中返回。如规范中所述，查询结果可能会是一些数据和一些错误，并且应当用以下形式的 JSON 对象返回：</p><pre class="prism language-js"><span class="punctuation">{</span>
  <span class="string">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span> <span class="punctuation">}</span><span class="punctuation">,</span>
  <span class="string">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span> <span class="punctuation">]</span>
<span class="punctuation">}</span></pre><p>如果没有返回错误，响应中不应当出现 <code>&quot;errors&quot;</code> 字段。如果没有返回数据，则 <a href="http://spec.graphql.cn//#sec-Data-" target="_blank" rel="nofollow noopener noreferrer">根据 GraphQL 规范</a>，只能在执行期间发生错误时才能包含 <code>&quot;data&quot;</code> 字段。</p><h2><a class="anchor" name="graphiql"></a>GraphiQL <a class="hash-link" href="#graphiql">#</a></h2><p>GraphiQL 在测试和开发过程中非常有用，但在生产环境下应当默认被禁用。如果你使用的是 express-graphql，可以根据 NODE_ENV 环境变量进行切换：</p><pre class="prism language-undefined">app<span class="punctuation">.</span><span class="function">use</span><span class="punctuation">(</span><span class="string">&#x27;/graphql&#x27;</span><span class="punctuation">,</span> <span class="function">graphqlHTTP</span><span class="punctuation">(</span><span class="punctuation">{</span>
  schema<span class="punctuation">:</span> MySessionAwareGraphQLSchema<span class="punctuation">,</span>
  graphiql<span class="punctuation">:</span> process<span class="punctuation">.</span>env<span class="punctuation">.</span>NODE_ENV <span class="operator">===</span> <span class="string">&#x27;development&#x27;</span><span class="punctuation">,</span>
<span class="punctuation">}</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">;</span></pre><h2><a class="anchor" name="node"></a>Node <a class="hash-link" href="#node">#</a></h2><p>如果你正在使用 NodeJS，我们推荐使用 <a href="https://github.com/graphql/express-graphql" target="_blank" rel="nofollow noopener noreferrer">express-graphql</a> 或 <a href="https://github.com/apollostack/graphql-server" target="_blank" rel="nofollow noopener noreferrer">graphql-server</a>。</p></div><a class="read-next" href="/learn/authorization"><span class="read-next-continue">继续阅读 →</span><span class="read-next-title">授权</span></a></div><div class="nav-docs"><div><h3>学习</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">入门</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">查询和变更</a><ul><li><a href="/learn/queries/#fields">字段（Fields）</a></li><li><a href="/learn/queries/#arguments">参数（Arguments）</a></li><li><a href="/learn/queries/#aliases">别名（Aliases）</a></li><li><a href="/learn/queries/#fragments">片段（Fragments）</a></li><li><a href="/learn/queries/#operation-name">操作名称（Operation Name）</a></li><li><a href="/learn/queries/#variables">变量（Variables）</a></li><li><a href="/learn/queries/#directives">指令（Directives）</a></li><li><a href="/learn/queries/#mutations">变更（Mutations）</a></li><li><a href="/learn/queries/#inline-fragments">内联片段（Inline Fragments）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schema 和类型</a><ul><li><a href="/learn/schema/#type-system">类型系统（Type System）</a></li><li><a href="/learn/schema/#type-language">类型语言（Type Language）</a></li><li><a href="/learn/schema/#object-types-and-fields">对象类型和字段（Object Types and Fields）</a></li><li><a href="/learn/schema/#arguments">参数（Arguments）</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">查询和变更类型（The Query and Mutation Types）</a></li><li><a href="/learn/schema/#scalar-types">标量类型（Scalar Types）</a></li><li><a href="/learn/schema/#enumeration-types">枚举类型（Enumeration Types）</a></li><li><a href="/learn/schema/#lists-and-non-null">列表和非空（Lists and Non-Null）</a></li><li><a href="/learn/schema/#interfaces">接口（Interfaces）</a></li><li><a href="/learn/schema/#union-types">联合类型（Union Types）</a></li><li><a href="/learn/schema/#input-types">输入类型（Input Types）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">验证</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">执行</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">内省</a></li></ul></div><div><h3>最佳实践</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">介绍</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">关于 Graphs 的思考</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">通过 HTTP 提供服务</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">授权</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">分页</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">缓存</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">学习</a></h5><a href="/learn/">入门</a><a href="/learn/queries/">查询语言</a><a href="/learn/schema/">类型系统</a><a href="/learn/execution/">执行</a><a href="/learn/best-practices/">最佳实践</a></div><div><h5><a href="/code">代码</a></h5><a href="/code/#server-libraries">服务端</a><a href="/code/#graphql-clients">客户端</a><a href="/code/#tools">工具</a></div><div><h5><a href="/community">社区</a></h5><a href="/community/upcoming-events/">即将到来的活动</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>更多</h5><a href="/blog">GraphQL 团队博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">阅读规范</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GitHub</a><a href="https://github.com/xitu/graphql.github.io/edit/zh-Hans/site/learn/BestPractice-ServingOverHTTP.md" target="_blank" rel="noopener noreferrer">编辑本页 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script></body></html>