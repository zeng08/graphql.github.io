<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>分页 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta property="og:description" content="GraphQL 提供了 API 中数据的完整描述，提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，让 API 更加容易随着时间推移而演进，并提供强大的开发者工具。"/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.cn/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta name="twitter:description" content="GraphQL 提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，并让 API 更加容易随着时间推移而演进。"/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL 团队博客"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">学习</a><a href="/code/">代码</a><a href="/community/">社区</a><a href="/blog/">博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">规范</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="搜索文档..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>分页</h1><div><blockquote><p>不同的分页模型可以实现不同的客户端功能</p></blockquote><p>在 GraphQL 中一个常见的用例是遍历对象集合之间的连接（connection）。在 GraphQL 中有许多不同的方式来展示这些连接，为客户端开发人员提供了一组不同的功能。</p><h2><a class="anchor" name="复数"></a>复数 <a class="hash-link" href="#复数">#</a></h2><p>暴露对象之间连接的最简单方法是返回一个复数类型的字段。例如，如果我们想得到一个 R2-D2 的朋友列表，我们可以直接请求所有的朋友：</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><h2><a class="anchor" name="切片"></a>切片 <a class="hash-link" href="#切片">#</a></h2><p>但是，尽管如此，我们也意识到客户端可能需要其他行为。客户可能希望能够指定他们想要获取的朋友数量；也许他们只要前两个。所以我们想要暴露一些类似的东西：</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      name
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>但即使我们仅仅获得前两个结果，我们可能仍然想要在列表中分页：一旦客户端获取前两个朋友，他们可能会发送第二个请求来请求接下来的两个朋友。我们如何启用这个行为？</p><h2><a class="anchor" name="分页和边"></a>分页和边 <a class="hash-link" href="#分页和边">#</a></h2><p>我们有很多种方法来实现分页：</p><ul><li>我们可以像这样 <code>friends(first:2 offset:2)</code> 来请求列表中接下来的两个结果。</li><li>我们可以像这样 <code>friends(first:2 after:$friendId)</code>, 来请求我们上一次获取到的最后一个朋友之后的两个结果。</li><li>我们可以像这样 <code>friends(first:2 after:$friendCursor)</code>, 从最后一项中获取一个游标并使用它来分页。</li></ul><p>一般来说，我们发现<strong>基于游标的分页</strong>是最强大的分页。特别当游标是不透明的时，则可以使用基于游标的分页（通过为游标设置偏移或 ID）来实现基于偏移或基于 ID 的分页，并且如果分页模型在将来发生变化，则使用游标可以提供额外的灵活性。需要提醒的是，游标是不透明的，并且它们的格式不应该被依赖，我们建议用 base64 编码它们。</p><p>这导致我们遇到一个问题：我们如何从对象中获取游标？我们不希望游标放置在 <code>User</code> 类型上；它是连接的属性，而不是对象的属性。所以我们可能想要引入一个新的间接层；我们的 <code>friends</code> 字段应该给我们一个边（edge）的列表，边同时具有游标和底层节点：</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      edges <span class="punctuation">{</span>
        node <span class="punctuation">{</span>
          name
        <span class="punctuation">}</span>
        cursor
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>如果存在针对于边而不是针对于某一个对象的信息，则边这个概念也被证明是有用的。例如，如果我们想要在 API 中暴露“友谊时间”，将其放置在边里是很自然的。</p><h2><a class="anchor" name="列表的结尾、计数以及连接"></a>列表的结尾、计数以及连接 <a class="hash-link" href="#列表的结尾、计数以及连接">#</a></h2><p>现在我们有能力使用游标对连接进行分页，但是我们如何知道何时到达连接的结尾？我们必须继续查询，直到我们收到一个空列表，但是我们真的希望连接能够告诉我们什么时候到达结尾，这样我们不需要额外的请求。同样的，如果我们想知道关于连接本身的附加信息怎么办；例如，R2-D2 有多少个朋友？</p><p>为了解决这两个问题，我们的 <code>friends</code> 字段可以返回一个连接对象。然后，连接对象将具有边其中的字段以及其他信息（如总计数和有关下一页是否存在的信息）。所以我们的最终查询可能看起来像这样：</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      totalCount
      edges <span class="punctuation">{</span>
        node <span class="punctuation">{</span>
          name
        <span class="punctuation">}</span>
        cursor
      <span class="punctuation">}</span>
      pageInfo <span class="punctuation">{</span>
        endCursor
        hasNextPage
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>请注意，我们也可能在这个 <code>PageInfo</code> 对象中包含 <code>endCursor</code> 和 <code>startCursor</code>。这样，如果我们不需要边所包含的任何附加信息，我们就不需要查询边，因为我们从 <code>pageInfo</code> 获取了分页所需的游标。这导致连接的潜在可用性改进；相比于仅暴露 <code>edges</code> 列表，我们还可以暴露一个仅包含节点的专用列表，以避免使用间接层。</p><h2><a class="anchor" name="完整的连接模型"></a>完整的连接模型 <a class="hash-link" href="#完整的连接模型">#</a></h2><p>显然，这比我们原来只有复数的设计更复杂！但是通过采用这种设计，我们已经为客户解锁了许多功能：</p><ul><li>为列表分页的能力。</li><li>请求有关连接本身的信息的能力，如 <code>totalCount</code> 或 <code>pageInfo</code>。</li><li>请求有关边本身的信息的能力，如 <code>cursor</code> 或 <code>friendshipTime</code>。</li><li>改变我们后端如何实现分页的能力，因为用户仅使用不透明的游标。</li></ul><p>要查看此操作，在示例 schema 中有一个附加字段，称为 <code>friendsConnection</code>，它暴露了所有这些概念。你可以在示例查询中查看它。尝试将 <code>after</code> 参数从 <code>friendsConnection</code> 移除以查看分页如何受到影响。另外，尝试用连接上的 <code>friends</code> 辅助字段替换 <code>edges</code> 字段，当适用于客户端时，这样可以直接访问朋友列表而无需额外的边这一层。</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div></div><a class="read-next" href="/learn/caching"><span class="read-next-continue">继续阅读 →</span><span class="read-next-title">缓存</span></a></div><div class="nav-docs"><div><h3>学习</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">入门</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">查询和变更</a><ul><li><a href="/learn/queries/#fields">字段（Fields）</a></li><li><a href="/learn/queries/#arguments">参数（Arguments）</a></li><li><a href="/learn/queries/#aliases">别名（Aliases）</a></li><li><a href="/learn/queries/#fragments">片段（Fragments）</a></li><li><a href="/learn/queries/#operation-name">操作名称（Operation Name）</a></li><li><a href="/learn/queries/#variables">变量（Variables）</a></li><li><a href="/learn/queries/#directives">指令（Directives）</a></li><li><a href="/learn/queries/#mutations">变更（Mutations）</a></li><li><a href="/learn/queries/#inline-fragments">内联片段（Inline Fragments）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schema 和类型</a><ul><li><a href="/learn/schema/#type-system">类型系统（Type System）</a></li><li><a href="/learn/schema/#type-language">类型语言（Type Language）</a></li><li><a href="/learn/schema/#object-types-and-fields">对象类型和字段（Object Types and Fields）</a></li><li><a href="/learn/schema/#arguments">参数（Arguments）</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">查询和变更类型（The Query and Mutation Types）</a></li><li><a href="/learn/schema/#scalar-types">标量类型（Scalar Types）</a></li><li><a href="/learn/schema/#enumeration-types">枚举类型（Enumeration Types）</a></li><li><a href="/learn/schema/#lists-and-non-null">列表和非空（Lists and Non-Null）</a></li><li><a href="/learn/schema/#interfaces">接口（Interfaces）</a></li><li><a href="/learn/schema/#union-types">联合类型（Union Types）</a></li><li><a href="/learn/schema/#input-types">输入类型（Input Types）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">验证</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">执行</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">内省</a></li></ul></div><div><h3>最佳实践</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">介绍</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">关于 Graphs 的思考</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">通过 HTTP 提供服务</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">授权</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">分页</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">缓存</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">学习</a></h5><a href="/learn/">入门</a><a href="/learn/queries/">查询语言</a><a href="/learn/schema/">类型系统</a><a href="/learn/execution/">执行</a><a href="/learn/best-practices/">最佳实践</a></div><div><h5><a href="/code">代码</a></h5><a href="/code/#server-libraries">服务端</a><a href="/code/#graphql-clients">客户端</a><a href="/code/#tools">工具</a></div><div><h5><a href="/community">社区</a></h5><a href="/community/upcoming-events/">即将到来的活动</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>更多</h5><a href="/blog">GraphQL 团队博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">阅读规范</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GitHub</a><a href="https://github.com/xitu/graphql.github.io/edit/zh-Hans/site/learn/BestPractice-Pagination.md" target="_blank" rel="noopener noreferrer">编辑本页 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.5579056ea98ac05dd506.js"></script></body></html>