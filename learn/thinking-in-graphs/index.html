<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>关于 Graphs 的思考 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta property="og:description" content="GraphQL 提供了 API 中数据的完整描述，提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，让 API 更加容易随着时间推移而演进，并提供强大的开发者工具。"/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.cn/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: 一种用于 API 的查询语言。"/><meta name="twitter:description" content="GraphQL 提供让客户端能够准确地获取需要的数据而不包含任何冗余的能力，并让 API 更加容易随着时间推移而演进。"/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL 团队博客"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">学习</a><a href="/code/">代码</a><a href="/community/">社区</a><a href="/blog/">博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">规范</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="搜索文档..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>关于 Graphs 的思考</h1><div><h2><a class="anchor" name="一切皆是图-[\*](https://en.wikipedia.org/wiki/turtles_all_the_way_down)"></a>一切皆是图 <a href="https://en.wikipedia.org/wiki/Turtles_all_the_way_down" target="_blank" rel="nofollow noopener noreferrer">*</a> <a class="hash-link" href="#一切皆是图-[\*](https://en.wikipedia.org/wiki/turtles_all_the_way_down)">#</a></h2><blockquote><p>使用 GraphQL，你可以将你所有的业务建模为图</p></blockquote><p>图是将很多真实世界现象变成模型的强大工具，因为它们和我们自然的心理模型和基本过程的口头描述很相似。通过 GraphQL，你会把自己的业务领域通过定义 schema 建模成一张图；在你的 schema 里，你定义不同类型的节点以及它们之间是如何连接的。在客户端这边，这创建了一种类似于面向对象编程的模式：引用其他类型的类型。在服务器端，由于 GraphQL 定义了接口，你可以在任何后端自由的使用它（无论新旧！）。</p><h2><a class="anchor" name="共同语言"></a>共同语言 <a class="hash-link" href="#共同语言">#</a></h2><blockquote><p>命名是构建直观接口中一个困难但重要的部分</p></blockquote><p>考虑下把你的 GraphQL schema 作为一种给你的团队和用户的沟通的共同语言。为了建立一个好的 schema，你必须检查你用来描述业务的日常语言。举个例子，让我们尝试用简单的文字描述一个电子邮件应用程序：</p><ul><li>一个用户可以有多个邮箱账号</li><li>每个电子邮件帐户都有地址、收件箱、草稿箱、删除的邮件和发送的邮件</li><li>每封邮件都有发送人、接收日期、主题和正文</li><li>没有收件人地址，用户无法发送电子邮件</li></ul><p>命名是构建直观的接口中一个困难但重要的部分，所以花时间仔细地考虑对于你的问题域和用户什么事有意义的。您的团队应该对这些业务领域的规则形成共同的理解和共识，因为您需要为 GraphQL schema 中的节点和关系选择直观，耐用的名称。试着去想象一些你想执行的查询：</p><p>获取我所有帐户的收件箱里未读邮件的数量</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  accounts <span class="punctuation">{</span>
    inbox <span class="punctuation">{</span>
      unreadEmailCount
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>获取主账户的前二十封草稿邮件的“预览信息”</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  mainAccount <span class="punctuation">{</span>
    drafts<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="operator">...</span>previewInfo
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span>

<span class="keyword">fragment</span> previewInfo <span class="keyword">on</span> Email <span class="punctuation">{</span>
  subject
  bodyPreviewSentence
<span class="punctuation">}</span></pre><h2><a class="anchor" name="业务逻辑层"></a>业务逻辑层 <a class="hash-link" href="#业务逻辑层">#</a></h2><blockquote><p>你的业务逻辑层应作为执行业务域规则的唯一正确来源</p></blockquote><p>你应该在哪里定义真正的业务逻辑？你应该在哪里验证，检查用户权限？就是在专门的业务逻辑层里。你的业务逻辑层应作为执行业务域规则的唯一正确来源。</p><p><img src="/img/diagrams/business_layer.png" alt="业务逻辑层图"/></p><p>在上图中，系统中的所有入口点（REST、GraphQL和RPC）都将使用相同的验证、授权和错误处理规则进行处理。</p><h3><a class="anchor" name="使用旧有的数据"></a>使用旧有的数据 <a class="hash-link" href="#使用旧有的数据">#</a></h3><blockquote><p>希望构建一个描述客户端如何使用数据的 GraphQL schema，而不是镜像旧有的数据库 schema。</p></blockquote><p>有时候，你会发现自己正在使用不能完全反映客户端消费数据的旧有的数据源。在这种情况下，更倾向于构建一个描述客户端如何使用数据的 GraphQL  schema，而不是镜像旧有的数据库 schema。</p><p>构建一个表达“是什么”而不是“怎么做”的 GraphQL schema。然后，您可以改进执行的具体细节，而不会破坏与旧客户端的接口。</p><h2><a class="anchor" name="一次一步"></a>一次一步 <a class="hash-link" href="#一次一步">#</a></h2><blockquote><p>更频繁地进行验证和获得反馈</p></blockquote><p>不要试图一次就做一个模型来构建整个业务域。 而是一次只构建一个场景所需的部分 schema。渐渐地拓展 schema，你要更频繁地进行验证和获得反馈，以便寻找到构建的正确解决方案。</p></div><a class="read-next" href="/learn/serving-over-http"><span class="read-next-continue">继续阅读 →</span><span class="read-next-title">通过 HTTP 提供服务</span></a></div><div class="nav-docs"><div><h3>学习</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">入门</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">查询和变更</a><ul><li><a href="/learn/queries/#fields">字段（Fields）</a></li><li><a href="/learn/queries/#arguments">参数（Arguments）</a></li><li><a href="/learn/queries/#aliases">别名（Aliases）</a></li><li><a href="/learn/queries/#fragments">片段（Fragments）</a></li><li><a href="/learn/queries/#operation-name">操作名称（Operation Name）</a></li><li><a href="/learn/queries/#variables">变量（Variables）</a></li><li><a href="/learn/queries/#directives">指令（Directives）</a></li><li><a href="/learn/queries/#mutations">变更（Mutations）</a></li><li><a href="/learn/queries/#inline-fragments">内联片段（Inline Fragments）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schema 和类型</a><ul><li><a href="/learn/schema/#type-system">类型系统（Type System）</a></li><li><a href="/learn/schema/#type-language">类型语言（Type Language）</a></li><li><a href="/learn/schema/#object-types-and-fields">对象类型和字段（Object Types and Fields）</a></li><li><a href="/learn/schema/#arguments">参数（Arguments）</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">查询和变更类型（The Query and Mutation Types）</a></li><li><a href="/learn/schema/#scalar-types">标量类型（Scalar Types）</a></li><li><a href="/learn/schema/#enumeration-types">枚举类型（Enumeration Types）</a></li><li><a href="/learn/schema/#lists-and-non-null">列表和非空（Lists and Non-Null）</a></li><li><a href="/learn/schema/#interfaces">接口（Interfaces）</a></li><li><a href="/learn/schema/#union-types">联合类型（Union Types）</a></li><li><a href="/learn/schema/#input-types">输入类型（Input Types）</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">验证</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">执行</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">内省</a></li></ul></div><div><h3>最佳实践</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">介绍</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">关于 Graphs 的思考</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">通过 HTTP 提供服务</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">授权</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">分页</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">缓存</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">学习</a></h5><a href="/learn/">入门</a><a href="/learn/queries/">查询语言</a><a href="/learn/schema/">类型系统</a><a href="/learn/execution/">执行</a><a href="/learn/best-practices/">最佳实践</a></div><div><h5><a href="/code">代码</a></h5><a href="/code/#server-libraries">服务端</a><a href="/code/#graphql-clients">客户端</a><a href="/code/#tools">工具</a></div><div><h5><a href="/community">社区</a></h5><a href="/community/upcoming-events/">即将到来的活动</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>更多</h5><a href="/blog">GraphQL 团队博客</a><a href="http://spec.graphql.cn/" target="_blank" rel="noopener noreferrer">阅读规范</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GitHub</a><a href="https://github.com/xitu/graphql.github.io/edit/zh-Hans/site/learn/BestPractice-ThinkingInGraphs.md" target="_blank" rel="noopener noreferrer">编辑本页 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script></body></html>